---
layout: post
title: ë°±ì¤€ 3184. ì–‘
date: 2021-02-07 16:00:00 +09:00
modified: 
category: algorithm
tags: [ps, c++, dfs]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/3184](https://www.acmicpc.net/problem/3184)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì‹¤íŒ¨]<br>
    ê° ì •ì  ë³„ ì‹œì‘ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ìƒ‰ê³¼ ë„ì°©ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ìƒ‰ ìˆ˜ ì„¸ê¸°<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    dfsë¡œ ì‹œì‘ì ì—ì„œ ë„ì°©ì ê¹Œì§€ ëª¨ë“  ì •ì  ìµœì†Œ ê²€ì€ìƒ‰ ìˆ˜ í™•ì¸<br>
    visited ë°°ì—´ì— í™•ì¸í•œ ìœ„ì¹˜ í‘œì‹œ<br>
ğŸ’¡ [3ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    visited ë°°ì—´ ëŒ€ì‹  visited ë§ˆí‚¹ìœ¼ë¡œ í™•ì¸í•œ ìœ„ì¹˜ í‘œì‹œ<br>
ğŸ’¡ [4ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    3ì°¨ ì‹œë„ ì‹œ ì‘ì„±í•œ dfs í•¨ìˆ˜ ë‚´ì—ì„œ ë°˜ë³µë˜ëŠ” push ë™ì‘ì„ ëŒë‹¤í•¨ìˆ˜ë¡œ í‘œí˜„<br>


### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ë§ˆë‹¹ì—ì„œ íƒˆì¶œí•  ìˆ˜ ìˆìœ¼ë©´ ì˜ì—­ìœ¼ë¡œ ê°„ì£¼í•˜ì§€ ì•ŠìŒ â†’ ë²”ìœ„ ì¡°ì ˆ & í…Œë‘ë¦¬ ì œì™¸
1. ì˜ì—­ ë‚˜ëˆ„ê³  ëŠ‘ëŒ€ & ì–‘ ìˆ˜ ì„¸ê¸° â†’ dfs

### ì½”ë“œ êµ¬í˜„ 
1. **í…Œë‘ë¦¬ ì œì™¸**<br>
    ìƒˆë¡œìš´ ìœ„ì¹˜ë¥¼ í™•ì¸í•  ê²½ìš° `isValid` í•¨ìˆ˜ë¡œ í…Œë‘ë¦¬ ì¸ì§€ ì•„ë‹Œì§€ ì²´í¬
    ```c++
    bool isValid(int i, int j){
        return i>0 && i<r-1 && j>0 && j<c-1;
    }
    ```
    í…Œë‘ë¦¬ ì˜ì—­ê³¼ ì—°ê²°ë˜ì–´ ìˆëŠ” ëª¨ë“  ì˜ì—­ì„ dfs í™•ì¸ ìœ„ì¹˜ì—ì„œ ì œì™¸
    ```c++
    void solution(){
        for(int i=0; i<r; i++){ 
            if(yard[i][0]=='.') dfs(i,0);
            if(yard[i][c-1]=='.') dfs(i,c-1);
        }
        for(int j=0; j<c; j++){
            if(yard[0][j]=='.') dfs(0,j);
            if(yard[r-1][j]=='.') dfs(r-1, j);
        }
        // ì˜ì—­ ë‚˜ëˆ„ê³  ìˆ«ì ì„¸ê¸°
        for(int i=1; i<r-1; i++){
            for(int j=1; j<c-1; j++){
                if(yard[i][j]!=FENCE && visited[i][j]==false){
                    dfs(i,j);
                }
            }
        }
    }
    ```
1. **dfs**<br>
    ìµœëŒ€ ë§ˆë‹¹ì˜ R,C<=250 ì´ë¯€ë¡œ MAX ì„ ì–¸
    ```c++
    #define MAX 251
    ```
    ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ìœ„ì¹˜ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” `yard` ë°°ì—´ ì„ ì–¸
    ```c++
    char yard[MAX][MAX];
    ```
    í™•ì¸í•œ ìœ„ì¹˜ë¥¼ ì²´í¬í•˜ê¸° ìœ„í•œ `visited` ë°°ì—´ ì„ ì–¸
    ```c++
    char yard[MAX][MAX];
    ```
    ëŠ‘ëŒ€ì™€ ì–‘ì˜ ìˆ˜ë¥¼ ì„¸ê¸° ìœ„í•œ ë³€ìˆ˜ ì„ ì–¸
    ```c++
    int sC=0, wC=0;
    ```
    ì‚´í´ë³´ëŠ” path ì €ì¥ì„ ìœ„í•œ ìŠ¤íƒ ì„ ì–¸
    ```c++
    stack<pair<int, int>> st; // pair<i,j>
    ```
    0,0 ìœ„ì¹˜ë¶€í„° ì‹œì‘
    ```c++
    visited[0][0]=true;
    st.push(make_pair(0,0));
    ```
    ìŠ¤íƒì˜ topì— ìˆëŠ” ìœ„ì¹˜ì— ëŠ‘ëŒ€ ë˜ëŠ” ì–‘ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³ <br> 
    4ë°©í–¥ ì¤‘ ì´ë™ ê°€ëŠ¥í•œ ê³³ì´ ìˆë‹¤ë©´ ìŠ¤íƒì— push
    ```c++
    int dirX[] = {0,1,0,-1}; // ì „ì—­ ë³€ìˆ˜
    int dirY[] = {1,0,-1,0}; // ì „ì—­ ë³€ìˆ˜

    while(!st.empty()){
        auto target = st.top();
        //cout<<target.first<<","<<target.second<<"\n";
        if(yard[target.first][target.second]==WOLF) {
            yard[target.first][target.second] = BLANK;
            wC++;
        }
        else if(yard[target.first][target.second]==SHEEP) {
            yard[target.first][target.second] = BLANK;
            sC++;
        }
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && visited[nextX][nextY]==false){
                able = true;
                visited[nextX][nextY]=true;
                st.push(make_pair(nextX, nextY));
            }
        }
        if(!able) st.pop();
    }
    ```
    ìµœì¢…ì ìœ¼ë¡œ ì–‘ì˜ ìˆ˜ê°€ ëŠ‘ëŒ€ ìˆ˜ë³´ë‹¤ ë§ìœ¼ë©´, ì–‘ì˜ ìˆ˜ë§Œ ì¶”ê°€<br>
    ëŠ‘ëŒ€ ìˆ˜ê°€ ì–‘ì˜ ìˆ˜ë³´ë‹¤ ë§ê±°ë‚˜ ê°™ë‹¤ë©´, ëŠ‘ëŒ€ ìˆ˜ë§Œ ì¶”ê°€
    ```c++
    int sCount=0, wCount=0; // ì „ì—­ ë³€ìˆ˜

    if(sC>wC) sCount+=sC;
    else wCount+=wC;
    ```
    ì§€ê¸ˆê¹Œì§€ ì‘ì„±í•œ dfs í•¨ìˆ˜ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.<br>
    ```c++
    void dfs(int i, int j){
        int sC=0, wC=0;

        stack<pair<int, int>> st; // pair<i,j>
        visited[i][j]=true;
        st.push(make_pair(i,j));
        while(!st.empty()){
            auto target = st.top();
            //cout<<target.first<<","<<target.second<<"\n";
            if(yard[target.first][target.second]==WOLF) {
                yard[target.first][target.second] = BLANK;
                wC++;
            }
            else if(yard[target.first][target.second]==SHEEP) {
                yard[target.first][target.second] = BLANK;
                sC++;
            }
            bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
            // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
            for(int dir=0; dir<4; dir++){
                int nextX = target.first+dirX[dir];
                int nextY = target.second+dirY[dir];
                // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
                if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && visited[nextX][nextY]==false){
                    able = true;
                    visited[nextX][nextY]=true;
                    st.push(make_pair(nextX, nextY));
                }
            }
            if(!able) st.pop();
        }
        if(sC>wC) sCount+=sC;
        else wCount+=wC;
    }
    ```
    ê²°ê³¼ ì¶œë ¥ ë¶€ë¶„ì„ solution í•¨ìˆ˜ì— ì¶”ê°€
    ```c++
    // ê²°ê³¼ ì¶œë ¥
    cout<<sCount<<" "<<wCount<<"\n";
    ```

ì—¬ê¸°ê¹Œì§€ ì‘ì„±í•œ ì½”ë“œë¥¼ ì œì¶œí•´ì„œ `ë§ì•˜ìŠµë‹ˆë‹¤`ë¥¼ ë°›ì•˜ë‹¤.<br>

ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ ì‚¬ìš©ì„ ì¤„ì´ê¸° ìœ„í•´ visited ë°°ì—´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  `yard`ì— visitë¥¼ í‘œì‹œí•˜ë„ë¡ dfs í•¨ìˆ˜ë¥¼ ë³€ê²½í•´ì„œ ìƒˆë¡œìš´ `ë§ì•˜ìŠµë‹ˆë‹¤`ë¥¼ ë°›ì•˜ë‹¤.<br>

```c++
#define VISIT '-'

void dfs(int i, int j){
    int sC=0, wC=0;

    stack<pair<int, int>> st; // pair<i,j>
    if(yard[i][j]==WOLF) wC++;
    if(yard[i][j]==SHEEP) sC++;
    yard[i][j]=VISIT;
    st.push(make_pair(i,j));
    while(!st.empty()){
        auto target = st.top();
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && yard[nextX][nextY]!=VISIT){
                able = true;
                if(yard[nextX][nextY]==WOLF) wC++;
                if(yard[nextX][nextY]==SHEEP) sC++;
                yard[nextX][nextY]=VISIT;
                st.push(make_pair(nextX, nextY));
            }
        }
        if(!able) st.pop();
    }
    if(sC>wC) sCount+=sC;
    else wCount+=wC;
}
```

ìœ„ ì²˜ëŸ¼ dfs í•¨ìˆ˜ë¥¼ ë³€ê²½í•˜ë‹ˆ ìŠ¤íƒ pushë¥¼ ìœ„í•œ ë™ì‘ì¸ ë°˜ë³µë˜ì–´ ì´ë¥¼ dfs ë‚´ì— ëŒë‹¤ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ë³€ê²½í–ˆê³  ë˜ ìƒˆë¡œìš´ `ë§ì•˜ìŠµë‹ˆë‹¤`ë¥¼ ë°›ì•˜ë‹¤.<br>
```c++
void dfs(int i, int j){
    int sC=0, wC=0;
    stack<pair<int, int>> st; // pair<i,j>

    auto pushSt = [&](int i, int j){ 
        if(yard[i][j]==WOLF) wC++;
        if(yard[i][j]==SHEEP) sC++;
        yard[i][j]=VISIT;
        return st.push(make_pair(i,j));
    };
    pushSt(i,j);
    while(!st.empty()){
        auto target = st.top();
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && yard[nextX][nextY]!=VISIT){
                able = true;
                pushSt(nextX,nextY);
            }
        }
        if(!able) st.pop();
    }
    if(sC>wC) sCount+=sC;
    else wCount+=wC;
}
```

### ì „ì²´ ì½”ë“œ
```c++
// 2ì°¨ ì‹œë„ - visited ë°°ì—´ ì‚¬ìš©
#include<iostream>
#include<stack>
#define MAX 251
#define WOLF 'v'
#define SHEEP 'o'
#define FENCE '#'
#define BLANK '.'

using namespace std;

int dirX[] = {0,1,0,-1};
int dirY[] = {1,0,-1,0};

char yard[MAX][MAX];
bool visited[MAX][MAX];
int r,c;
int sCount=0, wCount=0;

bool isValid(int i, int j){
    return i>0 && i<r-1 && j>0 && j<c-1;
}
void dfs(int i, int j){
    int sC=0, wC=0;

    stack<pair<int, int>> st; // pair<i,j>
    visited[i][j]=true;
    st.push(make_pair(i,j));
    while(!st.empty()){
        auto target = st.top();
        //cout<<target.first<<","<<target.second<<"\n";
        if(yard[target.first][target.second]==WOLF) {
            yard[target.first][target.second] = BLANK;
            wC++;
        }
        else if(yard[target.first][target.second]==SHEEP) {
            yard[target.first][target.second] = BLANK;
            sC++;
        }
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && visited[nextX][nextY]==false){
                able = true;
                visited[nextX][nextY]=true;
                st.push(make_pair(nextX, nextY));
            }
        }
        if(!able) st.pop();
    }
    if(sC>wC) sCount+=sC;
    else wCount+=wC;
}
// ì „ì²´ ìœ„ì¹˜ í™•ì¸ - í…Œë‘ë¦¬ ì œì™¸
void solution(){
    // íƒˆì¶œ ì¹¸ í™•ì¸ - ëŠ‘ëŒ€/ì–‘ ëª¨ë‘ ë§ˆë‹¹ ì•ˆì— ìˆìœ¼ë‹ˆ count=0ì´ë¯€ë¡œ ê´œì¶˜ 
    for(int i=0; i<r; i++){ 
        if(yard[i][0]=='.') dfs(i,0);
        if(yard[i][c-1]=='.') dfs(i,c-1);
    }
    for(int j=0; j<c; j++){
        if(yard[0][j]=='.') dfs(0,j);
        if(yard[r-1][j]=='.') dfs(r-1, j);
    }
    // ì˜ì—­ ë‚˜ëˆ„ê³  ìˆ«ì ì„¸ê¸°
    for(int i=1; i<r-1; i++){
        for(int j=1; j<c-1; j++){
            if(yard[i][j]!=FENCE && visited[i][j]==false){
                dfs(i,j);
            }
        }
    }
    // ê²°ê³¼ ì¶œë ¥
    cout<<sCount<<" "<<wCount<<"\n";
}
int main(){
    cin>>r>>c;
    for(int i=0; i<r; i++){
        string s; cin>>s;
        int cIdx=0;
        for(char each: s){
            yard[i][cIdx++] = each;
        }
    }
    solution();
}
```
```c++
// 3ì°¨ ì‹œë„ - visited ë°°ì—´ ì•„ë‹Œ visited ë§ˆí‚¹ ì‚¬ìš©
#include<iostream>
#include<stack>
#define MAX 251
#define WOLF 'v'
#define SHEEP 'o'
#define FENCE '#'
#define BLANK '.'
#define VISIT '-'

using namespace std;

int dirX[] = {0,1,0,-1};
int dirY[] = {1,0,-1,0};
char yard[MAX][MAX];
int r,c;
int sCount=0, wCount=0;

bool isValid(int i, int j){
    return i>0 && i<r-1 && j>0 && j<c-1;
}
void dfs(int i, int j){
    int sC=0, wC=0;

    stack<pair<int, int>> st; // pair<i,j>
    if(yard[i][j]==WOLF) wC++;
    if(yard[i][j]==SHEEP) sC++;
    yard[i][j]=VISIT;
    st.push(make_pair(i,j));
    while(!st.empty()){
        auto target = st.top();
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && yard[nextX][nextY]!=VISIT){
                able = true;
                if(yard[nextX][nextY]==WOLF) wC++;
                if(yard[nextX][nextY]==SHEEP) sC++;
                yard[nextX][nextY]=VISIT;
                st.push(make_pair(nextX, nextY));
            }
        }
        if(!able) st.pop();
    }
    if(sC>wC) sCount+=sC;
    else wCount+=wC;
}
// ì „ì²´ ìœ„ì¹˜ í™•ì¸ - í…Œë‘ë¦¬ ì œì™¸
void solution(){
    // íƒˆì¶œ ì¹¸ í™•ì¸ - ëŠ‘ëŒ€/ì–‘ ëª¨ë‘ ë§ˆë‹¹ ì•ˆì— ìˆìœ¼ë‹ˆ count=0ì´ë¯€ë¡œ ê´œì¶˜ 
    for(int i=0; i<r; i++){ 
        if(yard[i][0]==BLANK) dfs(i,0);
        if(yard[i][c-1]==BLANK) dfs(i,c-1);
    }
    for(int j=0; j<c; j++){
        if(yard[0][j]==BLANK) dfs(0,j);
        if(yard[r-1][j]==BLANK) dfs(r-1, j);
    }
    // ì˜ì—­ ë‚˜ëˆ„ê³  ìˆ«ì ì„¸ê¸°
    for(int i=1; i<r-1; i++){
        for(int j=1; j<c-1; j++){
            if(yard[i][j]!=FENCE && yard[i][j]!=VISIT){
                dfs(i,j);
            }
        }
    }
    // ê²°ê³¼ ì¶œë ¥
    cout<<sCount<<" "<<wCount<<"\n";
}
int main(){
    cin>>r>>c;
    for(int i=0; i<r; i++){
        string s; cin>>s;
        int cIdx=0;
        for(char each: s){
            yard[i][cIdx++] = each;
        }
    }
    solution();
}
```
```c++
// 4ì°¨ ì‹œë„ - visited ë§ˆí‚¹ ì‚¬ìš© & push ëŒë‹¤í•¨ìˆ˜
#include<iostream>
#include<stack>
#define MAX 251
#define WOLF 'v'
#define SHEEP 'o'
#define FENCE '#'
#define BLANK '.'
#define VISIT '-'

using namespace std;

int dirX[] = {0,1,0,-1};
int dirY[] = {1,0,-1,0};
char yard[MAX][MAX];
int r,c;
int sCount=0, wCount=0;

bool isValid(int i, int j){
    return i>0 && i<r-1 && j>0 && j<c-1;
}
void dfs(int i, int j){
    int sC=0, wC=0;
    stack<pair<int, int>> st; // pair<i,j>

    auto pushSt = [&](int i, int j){ 
        if(yard[i][j]==WOLF) wC++;
        if(yard[i][j]==SHEEP) sC++;
        yard[i][j]=VISIT;
        return st.push(make_pair(i,j));
    };
    pushSt(i,j);
    while(!st.empty()){
        auto target = st.top();
        bool able = false; // ì´ë™ì´ ë¶ˆê°€ëŠ¥í•˜ë©´ pop í•´ì•¼í•¨ 
        // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
        for(int dir=0; dir<4; dir++){
            int nextX = target.first+dirX[dir];
            int nextY = target.second+dirY[dir];
            // ìƒˆë¡œ ê°ˆ ê³³ì´ ìˆë‹¤ë©´
            if(isValid(nextX, nextY) && yard[nextX][nextY]!=FENCE && yard[nextX][nextY]!=VISIT){
                able = true;
                pushSt(nextX,nextY);
            }
        }
        if(!able) st.pop();
    }
    if(sC>wC) sCount+=sC;
    else wCount+=wC;
}
// ì „ì²´ ìœ„ì¹˜ í™•ì¸ - í…Œë‘ë¦¬ ì œì™¸
void solution(){
    // íƒˆì¶œ ì¹¸ í™•ì¸ - ëŠ‘ëŒ€/ì–‘ ëª¨ë‘ ë§ˆë‹¹ ì•ˆì— ìˆìœ¼ë‹ˆ count=0ì´ë¯€ë¡œ ê´œì¶˜ 
    for(int i=0; i<r; i++){ 
        if(yard[i][0]==BLANK) dfs(i,0);
        if(yard[i][c-1]==BLANK) dfs(i,c-1);
    }
    for(int j=0; j<c; j++){
        if(yard[0][j]==BLANK) dfs(0,j);
        if(yard[r-1][j]==BLANK) dfs(r-1, j);
    }
    // ì˜ì—­ ë‚˜ëˆ„ê³  ìˆ«ì ì„¸ê¸°
    for(int i=1; i<r-1; i++){
        for(int j=1; j<c-1; j++){
            if(yard[i][j]!=FENCE && yard[i][j]!=VISIT){
                dfs(i,j);
            }
        }
    }
    // ê²°ê³¼ ì¶œë ¥
    cout<<sCount<<" "<<wCount<<"\n";
}
int main(){
    cin>>r>>c;
    for(int i=0; i<r; i++){
        string s; cin>>s;
        int cIdx=0;
        for(char each: s){
            yard[i][cIdx++] = each;
        }
    }
    solution();
}
```


