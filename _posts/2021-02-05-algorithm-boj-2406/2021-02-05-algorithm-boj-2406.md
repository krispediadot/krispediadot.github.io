---
layout: post
title: ë°±ì¤€ 2406. ì•ˆì •ì ì¸ ë„¤íŠ¸ì›Œí¬
date: 2021-02-05 11:58:47 +09:00
modified: 
category: algorithm
tags: [ps, c++, union-find, kruskal]
image: "/assets/img/avatar_code.png"
cover: "./puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/2406](https://www.acmicpc.net/problem/2406)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì‹¤íŒ¨]<br>
    ì—°ê²° ì•ˆ ëœ ë…¸ë“œë¥¼ set ìë£Œ êµ¬ì¡°ì— ë„£ê³  í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ì—ì§€ ì¤‘ ë¹„ìš©ì´ ë‚®ì€ ì—ì§€ë¥¼ ì„ íƒí•´ì„œ ì—°ê²°<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    MSTìƒì„±<br>


### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ì»´í“¨í„°ì™€ ì—°ê²° ë„¤íŠ¸ì›Œí¬ê°€ ìˆë‹¤. â†’ ë…¸ë“œì™€ ì—ì§€
1. ì´ë¯¸ ì—°ê²°ëœ ë„¤íŠ¸ì›Œí¬ ìˆìŒ â†’ connectedì— ì €ì¥
1. ìƒˆë¡œ ì—°ê²°í•˜ëŠ”ë° ë“œëŠ” ë¹„ìš© ì¸ì ‘í–‰ë ¬ë¡œ ì£¼ì–´ì§ â†’ edgesì— ì €ì¥
1. ìµœì†Œí•œì˜ ë¹„ìš©ìœ¼ë¡œ ì•ˆì •ì ìœ¼ë¡œ ë§Œë“¬ â†’ kruskal ì•Œê³ ë¦¬ì¦˜

### ì½”ë“œ êµ¬í˜„ 
1. **ë…¸ë“œì™€ ì—ì§€**<br>
    í’€ì´ë¥¼ ìœ„í•´ì„œëŠ” ì—ì§€ë§Œ í•„ìš”í•˜ë¯€ë¡œ pairë¡œ í‘œí˜„
1. **connected**<br>
    ```c++
    #include<vector>
    vector<pair<int,int>> connected;
    ```
    ì…ë ¥ ë°›ìŒ<br>
    ```c++
    for(int i=0; i<m; i++){
        pair<int, int> edge;
        cin>>edge.first>>edge.second;
        connected.push_back(edge);
    }
    ```
1. **edges**<br>
    ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ê°€ì¤‘ì¹˜ ì¸ì ‘í–‰ë ¬ì„<br>
    `pair<ê°€ì¤‘ì¹˜, pair<ë…¸ë“œ1, ë…¸ë“œ2>>`ë¡œ í‘œí˜„
    ```c++
    #include<vector>
    vector<pair<int, pair<int, int>>> edges;
    ```
    ì…ë ¥ ë°›ìŒ<br>
    <mark>ì—¬ê¸°ì„œ ê³ ë ¤í•  ì‚¬í•­</mark>ì€ ë…¸ë“œê°€ ìê¸°ìì‹ ê³¼ ì—°ê²°í•  í•„ìš” ì—†ê³  ì§€ì‚¬ ì»´í“¨í„°(1ë²ˆ ì»´í“¨í„°)ì™€ëŠ” ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆìœ¼ë‹ˆ ë‹¤ì‹œ ì—°ê²°í•  í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ <mark>ë…¸ë“œ1==ë…¸ë“œ2ì¸ ê²½ìš°ì™€ ë…¸ë“œ1 ë˜ëŠ” ë…¸ë“œ2ê°€ ì§€ì‚¬ ì»´í“¨í„°(1ë²ˆ ì»´í“¨í„°)ì¸ ê²½ìš°ëŠ” edgesì— ì €ì¥í•  í•„ìš”ê°€ ì—†ë‹¤</mark>ëŠ” ì ì´ë‹¤.<br>
    ```c++
    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            int cost; cin>>cost;
            if(i==j || i==1 || j==1) continue;
            edges.push_back(make_pair(cost,make_pair(i,j)));
        }
    }
    ```

1. **kruskal ì•Œê³ ë¦¬ì¦˜**<br>
    solution í•¨ìˆ˜ì— kruskal ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•œë‹¤.<br>
    ><mark>kruskal ì•Œê³ ë¦¬ì¦˜</mark>ì— ëŒ€í•´ ê°„ë‹¨íˆ ì„¤ëª…í•˜ìë©´<br>
    >íƒìš•ì  ë°©ë²•ì„ ì´ìš©í•´ ë„¤íŠ¸ì›Œí¬ì˜ ëª¨ë“  ì •ì ì„ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ëŠ” ìµœì  í•´ë‹µì„ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
    >ì£¼ìš” í¬ì¸íŠ¸ëŠ” <mark>ìµœì†Œ ë¹„ìš©</mark>ìœ¼ë¡œ, <mark>ì‚¬ì´í´ì„ ë§Œë“¤ì§€ ì•Šë„ë¡ í•œë‹¤</mark>ëŠ” ì ì´ë‹¤.<br>
    ><mark>ìµœì†Œ ë¹„ìš©</mark>ìœ¼ë¡œ ì—°ê²°í•˜ê¸° ìœ„í•´ ëª¨ë“  ì—ì§€ë“¤ì„ ë¹„ìš©ì´ ë‚®ì€ ìˆœì„œëŒ€ë¡œ <mark>ì •ë ¬</mark>í•˜ê³ <br>
    ><mark>ì‚¬ì´í´ì„ ë§Œë“¤ì§€ ì•Šê¸° ìœ„í•´</mark> ìƒˆë¡œ ì—ì§€ë¥¼ ì—°ê²°í•  ë•Œ <mark>union-find ì•Œê³ ë¦¬ì¦˜</mark>ìœ¼ë¡œ ì‚¬ì´í´ì´ ìƒì„±ë˜ëŠ”ì§€ í™•ì¸í•œë‹¤.<br><br>

    ê°€ì¥ ë¨¼ì € ê° ë…¸ë“œì˜ ê·¸ë£¹ì„ í™•ì¸í•˜ê¸° ìœ„í•œ ë²¡í„° ìƒì„±
    ```c++
    #include<vector>
    vector<int> setInfo;
    ```

    solution í•¨ìˆ˜ ë‚´ì—ì„œ ì´ˆê¸°í™”
    ```c++
    for(int i=0; i<=n; i++) setInfo.push_back(i);
    ```

    ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ” ì—ì§€ ì •ë³´ ì—…ë°ì´íŠ¸ 
    ```c++
    for(auto each: connected) {
        if(findSet(each.first) != findSet(each.second))
            unionSet(each.first, each.second);
    }
    ```

    ì—ì§€ ë¹„ìš©ì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    ```c++
    #include<algorithm>
    sort(edges.begin(), edges.end());
    ```

    ì—°ê²°ë˜ì–´ ìˆì§€ ì•Šì€ ë…¸ë“œ ì—°ê²°
    ```c++
    for(auto each: edges){
        if(findSet(each.second.first) != findSet(each.second.second)){
            unionSet(each.second.first, each.second.second);
            connected.push_back(each.second);
        }
    }
    ```

    í˜„ì¬ê¹Œì§€ ì‘ì„±í•œ solution í•¨ìˆ˜ì˜ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ë‹¤.<br>
    ```c++
    void solution(){
        // setInfo ì´ˆê¸°í™”
        for(int i=0; i<=n; i++) setInfo.push_back(i);
        for(auto each: connected) {
            if(findSet(each.first) != findSet(each.second))
                unionSet(each.first, each.second);
        }
        //ì—ì§€ í¬ê¸°ì— ë”°ë¼ ì •ë ¬ 
        sort(edges.begin(), edges.end());

        for(auto each: edges){
            if(findSet(each.second.first) != findSet(each.second.second)){
                unionSet(each.second.first, each.second.second);
                connected.push_back(each.second);
        }
    }
    ```

    ë¬¸ì œì—ì„œ ì¶œë ¥ìœ¼ë¡œ ë‚˜ì˜¤ê¸¸ ì›í•˜ëŠ” ìƒˆë¡œ ì¶”ê°€í•œ ì—ì§€ì˜ ë¹„ìš©ì„ `totalCost` ë³€ìˆ˜ë¡œ ì €ì¥í•˜ê³  ì—ì§€ì˜ ê°œìˆ˜ë¥¼ totalConnect ë³€ìˆ˜ë¡œ ì €ì¥í•œë‹¤.<br>
    <br>
    ë”°ë¼ì„œ ìµœì¢… solutioní•¨ìˆ˜ëŠ” ì•„ë˜ì™€ ê°™ë‹¤.<br>
    ```c++
    void solution(){
        int totalCost=0, totalConnect=0;
        // setInfo ì´ˆê¸°í™”
        for(int i=0; i<=n; i++) setInfo.push_back(i);
        for(auto each: connected) {
            if(findSet(each.first) != findSet(each.second))
                unionSet(each.first, each.second);
        }
        //ì—ì§€ í¬ê¸°ì— ë”°ë¼ ì •ë ¬ 
        sort(edges.begin(), edges.end());

        for(auto each: edges){
            if(findSet(each.second.first) != findSet(each.second.second)){
                unionSet(each.second.first, each.second.second);
                connected.push_back(each.second);
                totalCost+=each.first;
                totalConnect++;
            }
        }
        // ì¶œë ¥
        cout<<totalCost<<" "<<totalConnect<<"\n";
        for(int i=m; i<m+totalConnect; i++)
            cout<<connected[i].first<<" "<<connected[i].second<<"\n";
    }
    ```
    ì´ì œ solution í•¨ìˆ˜ì—ì„œ ì‚¬ìš©í•œ `findSet`ê³¼ `unionSet` í•¨ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.<br>
    <br>
    `findSet` í•¨ìˆ˜ëŠ” íƒ€ê²Ÿ ë…¸ë“œê°€ ì†í•œ ê·¸ë£¹ì´ ì–´ë””ì¸ì§€ë¥¼ í™•ì¸í•˜ë©´ ë˜ë¯€ë¡œ
    ```c++
    int findSet(int target){
        if(target==setInfo[target]) return target;
        return setInfo[target] = findSet(setInfo[target]);
    }
    ```
    `unionSet` í•¨ìˆ˜ëŠ” ë‘ê°œì˜ ë…¸ë“œê°€ ë‹¤ë¥¸ ê·¸ë£¹ì— ì†í•´ìˆê³  ìƒˆë¡­ê²Œ ì—°ê²°í•´ì£¼ëŠ” ì—­í• ì„ í•˜ë©° ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•˜ë©´ ëœë‹¤.<br>
    ```c++
    void unionSet(int target1, int target2){
        int set1 = findSet(target1);
        int set2 = findSet(target2);

        if(set1 != set2){
            setInfo[set2] = set1;
        }
    }
    ```
    ìœ„ì—ì„œ ì‘ì„±í•œ `unionSet` í•¨ìˆ˜ëŠ” ê¸°ë³¸ì ì¸ êµ¬ì¡°ì´ê³  ìµœì í™”ë¥¼ í•˜ê¸° ìœ„í•´ **weighted-union**ê³¼ **path compression** ë°©ë²•ì´ ìˆë‹¤.<br>

    ìì„¸í•œ ì‚¬í•­ì€ union-find ì•Œê³ ë¦¬ì¦˜ì„ ë‹¤ë£° ë•Œ ìì„¸íˆ ì‘ì„±í•  ì˜ˆì •ì´ë‹¤.<br>

### ì „ì²´ ì½”ë“œ
```c++
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

vector<pair<int,int>> connected;
vector<pair<int, pair<int, int>>> edges;
vector<int> setInfo;
int n,m;

int findSet(int target){
    if(target==setInfo[target]) return target;
    return setInfo[target] = findSet(setInfo[target]);
}
void unionSet(int target1, int target2){
    int set1 = findSet(target1);
    int set2 = findSet(target2);

    if(set1 != set2){
        setInfo[set2] = set1;
    }
}
void solution(){
    int totalCost=0, totalConnect=0;
    // setInfo ì´ˆê¸°í™”
    for(int i=0; i<=n; i++) setInfo.push_back(i);
    for(auto each: connected) {
        if(findSet(each.first) != findSet(each.second))
            unionSet(each.first, each.second);
    }
    //ì—ì§€ í¬ê¸°ì— ë”°ë¼ ì •ë ¬ 
    sort(edges.begin(), edges.end());

    for(auto each: edges){
        if(findSet(each.second.first) != findSet(each.second.second)){
            unionSet(each.second.first, each.second.second);
            connected.push_back(each.second);
            totalCost+=each.first;
            totalConnect++;
        }
    }
    // ì¶œë ¥
    cout<<totalCost<<" "<<totalConnect<<"\n";
    for(int i=m; i<m+totalConnect; i++)
        cout<<connected[i].first<<" "<<connected[i].second<<"\n";
}
int main(){
    cin>>n>>m;
    for(int i=0; i<m; i++){
        pair<int, int> edge;
        cin>>edge.first>>edge.second;
        connected.push_back(edge);
    }
    for(int i=1; i<=n; i++){
        for(int j=1; j<=n; j++){
            int cost; cin>>cost;
            if(i==j || i==1 || j==1) continue;
            edges.push_back(make_pair(cost,make_pair(i,j)));
        }
    }
    solution();
}
```




