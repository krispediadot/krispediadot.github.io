---
layout: post
title: ë°±ì¤€ 7562. ë‚˜ì´íŠ¸ì˜ ì´ë™
date: 2021-02-07 16:00:00 +09:00
modified: 
category: problem solving
tags: [ps, c++, bfs]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/7562](https://www.acmicpc.net/problem/7562)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì„±ê³µ]<br>
    ê° ì •ì  ë³„ ì‹œì‘ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ìƒ‰ê³¼ ë„ì°©ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ìƒ‰ ìˆ˜ ì„¸ê¸°<br>


### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ë‚˜ì´íŠ¸ëŠ” 8ë°©í–¥ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆë‹¤. â†’ ë°©í–¥ ì„¤ì •
1. ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ ì—°ì†ì ìœ¼ë¡œ ì´ë™í•˜ë©° í™•ì¸í•´ì•¼í•œë‹¤. â†’ bfs

### ì½”ë“œ êµ¬í˜„ 
1. **ë°©í–¥ ì„¤ì •**<br>
    ```c++
    int dirX[] = {-2, -1, 1, 2, 2, 1, -1, -2};
    int dirY[] = {1, 2, 2, 1, -1, -2, -2, -1};
    ```
1. **bfs**<br>
    visited ë°°ì—´ì— ë°©ë¬¸í–ˆë˜ ìœ„ì¹˜ í‘œì‹œ
    ```c++
    #define MAX 301
    bool visited[MAX][MAX]; //ì „ì—­ ë³€ìˆ˜
    ```
    8ë°©í–¥ìœ¼ë¡œ ì´ë™í•˜ë©° ë„ì°© ìœ„ì¹˜ì— ë„ë‹¬í•  ë•Œê¹Œì§€ queueì— push
    ```c++
    void solution(pair<int, int> from, pair<int, int> to) {
        if (from.first == to.first && from.second == to.second) {
            cout << 0 << "\n";
            return;
        }
        memset(visited, false, sizeof(visited));
        queue<pair<int, pair<int, int>>> q;
        q.push(make_pair(0, from));
        while (!q.empty()) {
            auto target = q.front();
            q.pop();
            for (int dir = 0; dir < 8; dir++) {
                int nextX = target.second.first + dirX[dir];
                int nextY = target.second.second + dirY[dir];
                int nextStep = target.first + 1;

                if (isValid(nextX, nextY) && visited[nextX][nextY] == false) {
                    if (nextX == to.first && nextY == to.second) {
                        cout << nextStep << "\n";
                        return;
                    }
                    visited[nextX][nextY] = true;
                    q.push(make_pair(nextStep, make_pair(nextX, nextY)));
                }
            }
        }
    }
    ```

### ì „ì²´ ì½”ë“œ
```c++
#include <iostream>
#include <queue>
#include <cstring>
#define MAX 301

using namespace std;

bool visited[MAX][MAX];
int dirX[] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dirY[] = {1, 2, 2, 1, -1, -2, -2, -1};
int n;

bool isValid(int i, int j) {
    return i >= 0 && i < n && j >= 0 && j < n;
}
void solution(pair<int, int> from, pair<int, int> to) {
    if (from.first == to.first && from.second == to.second) {
        cout << 0 << "\n";
        return;
    }
    memset(visited, false, sizeof(visited));
    queue<pair<int, pair<int, int>>> q;
    q.push(make_pair(0, from));
    while (!q.empty()) {
        auto target = q.front();
        q.pop();
        for (int dir = 0; dir < 8; dir++) {
            int nextX = target.second.first + dirX[dir];
            int nextY = target.second.second + dirY[dir];
            int nextStep = target.first + 1;

            if (isValid(nextX, nextY) && visited[nextX][nextY] == false) {
                if (nextX == to.first && nextY == to.second) {
                    cout << nextStep << "\n";
                    return;
                }
                visited[nextX][nextY] = true;
                q.push(make_pair(nextStep, make_pair(nextX, nextY)));
            }
        }
    }
}
int main() {
    int nTest; cin >> nTest;
    while (nTest--) {
        cin >> n;
        pair<int, int> from, to;
        cin >> from.first >> from.second;
        cin >> to.first >> to.second;
        solution(from, to);
    }
}
```

