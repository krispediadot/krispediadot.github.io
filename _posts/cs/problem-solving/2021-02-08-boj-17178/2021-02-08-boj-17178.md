---
layout: post
title: ë°±ì¤€ 17178. ì¤„ì„œê¸°
date: 2021-02-08 14:48:00 +09:00
modified: 
category: problem solving
tags: [ps, c++, stack, queue, set]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/17178](https://www.acmicpc.net/problem/17178)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì„±ê³µ]<br>
    í‹°ì¼“ ë²ˆí˜¸ ì „ë¶€ setì— ì €ì¥<br>
    setì€ ì´ì§„íŠ¸ë¦¬ë¡œ êµ¬ì„±ë˜ì–´ìˆê³  ì •ë ¬ì´ ë˜ë¯€ë¡œ ì •ë ¬ ê¸°ì¤€ì„ ë¬¸ì œì— ì•Œë§ê²Œ ì¡°ì •<br>
    ëŒ€ê¸°ì—´ì€ stack<br>
    ì¤„ì„œìˆëŠ” ì‚¬ëŒë“¤ì€ vector ì•ˆ vector<br>
    setì—ì„œ ë“¤ì–´ê°ˆ ìˆœì„œê°€ ëœ ì‚¬ëŒ targetìœ¼ë¡œ ì„¤ì • í›„ ëŒ€ê¸°ì—´ ë˜ëŠ” ì¤„ì„œìˆëŠ” ì‚¬ëŒ ì¤‘ì—ì„œ ì°¾ê¸° ê°€ëŠ¥í•œì§€ í™•ì¸<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    ì¤„ì„œìˆëŠ” ì‚¬ëŒë“¤ì„ vector ì•ˆ vectorê°€ ì•„ë‹Œ vector ì•ˆ queueë¡œ ë³€ê²½í•´ ë¶ˆí•„ìš”í•œ ë§ˆí‚¹ ì œê±°<br>


### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. í•œ ì¤„ì— 5ëª… ì„œìˆìŒ â†’ #defineìœ¼ë¡œ ì„ ì–¸
1. í‹°ì¼“ ë²ˆí˜¸ê°€ ì•ŒíŒŒë²³ & ìˆ«ì ì˜¤ë¦„ì°¨ìˆœ â†’ ticketCompare ê°ì²´ ì„ ì–¸ 
1. ì „ì²´ í‹°ì¼“ì˜ ìˆœì„œ í™•ì¸ â†’ set ì‚¬ìš©
1. í˜„ì¬ ì¤„ì„œìˆëŠ” ì‚¬ëŒë“¤ â†’ 2ì°¨ì› ë²¡í„° ì‚¬ìš©(1ì°¨ ì‹œë„)/vector ì•ˆ queue ì‚¬ìš©(2ì°¨ ì‹œë„)
1. í˜„ì¬ ë“¤ì–´ê°ˆ ì‚¬ëŒ ì…ì¥ ê°€ëŠ¥í•œì§€ í™•ì¸ â†’ setì—ì„œ íƒ€ê²Ÿ í™•ì¸ í›„ ëŒ€ê¸°ì—´ê³¼ ì¤„ì„œìˆëŠ” ì‚¬ëŒì—ì„œ ì°¾ê¸°

### ì½”ë“œ êµ¬í˜„ 
1. **#defineìœ¼ë¡œ ì„ ì–¸**<br>
    ```c++
    #define COL 5
    ```
1. **ticketCompare ê°ì²´ ì„ ì–¸**<br>
    ```c++
    struct ticketCompare {
        bool operator()(const string& t1, const string& t2) const {
            if (t1[0] == t2[0]) {
                return stoi(t1.substr(2, t1.length())) < stoi(t2.substr(2, t2.length()));
            }
            return t1 < t2;
        }
    };
    ```
1. **set ì‚¬ìš©**<br>
    ```c++
    #include <set>
    set<string, ticketCompare> tickets;
    ```
1. **2ì°¨ì› ë²¡í„° ì‚¬ìš©(1ì°¨ ì‹œë„)/vector ì•ˆ queue ì‚¬ìš©(2ì°¨ ì‹œë„)**<br>
    <mark>1ì°¨ ì‹œë„ì˜ line</mark><br>
    ```c++
    #include <vector>
    vector<vector<string>> line
    ```
    <mark>2ì°¨ ì‹œë„ì˜ line</mark><br>
    ```c++
    #include <vector>
    #include <queue>
    vector<queue<string>> line
    ```

1. **setì—ì„œ íƒ€ê²Ÿ í™•ì¸ í›„ ëŒ€ê¸°ì—´ê³¼ ì¤„ì„œìˆëŠ” ì‚¬ëŒì—ì„œ ì°¾ê¸°**<br>
    ëŒ€ê¸°ì—´ ìŠ¤íƒ ì„ ì–¸
    ```c++
    #include <stack>
    stack<string> waiting;
    ```

    <mark>ì§€ê¸ˆë¶€í„° ì„¤ëª…í•˜ëŠ” ë‚´ìš©ì€ 1ì°¨ ì‹œë„ì— ì‚¬ìš©í–ˆë˜ ë°©ì‹ì´ë‹¤.</mark><br>
    ê° íƒ€ê²Ÿ í™•ì¸ ë° í™•ì¸í•œ ì‚¬ëŒ `-`ë¡œ ë§ˆí‚¹
    ```c++
    string answer = "GOOD";
    while (!tickets.empty()) {
        pair<int, int> curLoc(0, 0);
        auto target = tickets.begin();

        if (!waiting.empty() && waiting.top() == *target) {
            waiting.pop();
            tickets.erase(target);
        }
        else if (line[curLoc.first][curLoc.second] == *target) {
            line[curLoc.first][curLoc.second] = "-";
            tickets.erase(target);
        }
        else {
            while(line[curLoc.first][curLoc.second] != *target) {
                if(line[curLoc.first][curLoc.second] != "-") {
                    waiting.push(line[curLoc.first][curLoc.second]);
                    line[curLoc.first][curLoc.second] = "-";
                }
                curLoc = nextLoc(curLoc);
                if (curLoc.first >= nLine) {
                    answer = "BAD";
                    break;
                }
            }
            if (answer == "BAD") break;
            line[curLoc.first][curLoc.second] = "-";
            curLoc = nextLoc(curLoc);
            tickets.erase(target);
        }
    }
    ```
    ê²°ê³¼ ì¶œë ¥ì„ í¬í•¨í•œ ìµœì¢… solution 
    ```c++
    pair<int, int> nextLoc(pair<int, int> curLoc) {
        curLoc.second++;
        if (curLoc.second >= 5) {
            curLoc.second = 0;
            curLoc.first++;
        }
        return curLoc;
    }
    void solution(set<string, ticketCompare> tickets, vector<vector<string>> line) {
        string answer = "GOOD"; // positive thinker
        stack<string> waiting;
        // pair<row, col>
        while (!tickets.empty()) {
            pair<int, int> curLoc(0, 0);
            auto target = tickets.begin();

            if (!waiting.empty() && waiting.top() == *target) {
                waiting.pop();
                tickets.erase(target);
            }
            else if (line[curLoc.first][curLoc.second] == *target) {
                line[curLoc.first][curLoc.second] = "-";
                tickets.erase(target);
            }
            else {
                while (line[curLoc.first][curLoc.second] != *target) {
                    if (line[curLoc.first][curLoc.second] != "-") {
                        waiting.push(line[curLoc.first][curLoc.second]);
                        line[curLoc.first][curLoc.second] = "-";
                    }
                    curLoc = nextLoc(curLoc);
                    if (curLoc.first >= nLine) {
                        answer = "BAD";
                        break;
                    }
                }
                if (answer == "BAD") break;
                line[curLoc.first][curLoc.second] = "-";
                curLoc = nextLoc(curLoc);
                tickets.erase(target);
            }
        }
        cout << answer;
    }
    ```

    <mark>ì•„ë˜ ë‚´ìš©ì€ 2ì°¨ ì‹œë„ì—ì„œ ì‚¬ìš©í•œ ë°©ì‹ì´ë‹¤.</mark><br>
    vector<vector<string>> ìœ¼ë¡œ ì„ ì–¸ë˜ì—ˆë˜ ì¤„ì„œìˆëŠ” ì‚¬ëŒì„ vector<queue<string>> ìœ¼ë¡œ ë³€ê²½í•˜ê³ <br>
    ë¶ˆí•„ìš”í•œ ë§ˆí‚¹ ì‘ì—…ì„ ì œê±°í•œ solution
    ```c++
    set<string, ticketCompare> tickets;
    vector<queue<string>> line;
    int nLine; 
    void solution() {
        string answer = "GOOD"; // positive thinker
        stack<string> waiting;
        int curLine = 0;
        while (!tickets.empty()) {
            auto target = tickets.begin();

            if (!waiting.empty() && waiting.top() == *target) {
                waiting.pop();
                tickets.erase(target);
            }
            else if (curLine >= nLine) {
                answer = "BAD";
                break;
            }
            else if (line[curLine].front() == *target) {
                line[curLine].pop();
                if (line[curLine].size() == 0) curLine++;
                tickets.erase(target);
            }
            else {
                while (line[curLine].front() != *target) {
                    waiting.push(line[curLine].front());
                    line[curLine].pop();
                    if (line[curLine].size() == 0) curLine++;
                    if (curLine >= nLine) {
                        answer = "BAD";
                        break;
                    }
                }
                if (answer == "BAD") break;
                line[curLine].pop();
                if (line[curLine].size() == 0) curLine++;
                tickets.erase(target);
            }
        }
        cout << answer;
    }
    ```

### ì „ì²´ ì½”ë“œ
```c++
// 1ì°¨ ì‹œë„
#include <iostream>
#include <vector>
#include <set>
#include <stack>
#define COL 5

using namespace std;

int nLine; 

struct ticketCompare {
    bool operator()(const string& t1, const string& t2) const {
        if (t1[0] == t2[0]) {
            return stoi(t1.substr(2, t1.length())) < stoi(t2.substr(2, t2.length()));
        }
        return t1 < t2;
    }
};
pair<int, int> nextLoc(pair<int, int> curLoc) {
    curLoc.second++;
    if (curLoc.second >= 5) {
        curLoc.second = 0;
        curLoc.first++;
    }
    return curLoc;
}
void solution(set<string, ticketCompare> tickets, vector<vector<string>> line) {
    string answer = "GOOD"; // positive thinker
    stack<string> waiting;
     // pair<row, col>
    while (!tickets.empty()) {
        pair<int, int> curLoc(0, 0);
        auto target = tickets.begin();

        if (!waiting.empty() && waiting.top() == *target) {
            waiting.pop();
            tickets.erase(target);
        }
        else if (line[curLoc.first][curLoc.second] == *target) {
            line[curLoc.first][curLoc.second] = "-";
            tickets.erase(target);
        }
        else {
            while (line[curLoc.first][curLoc.second] != *target) {
                if (line[curLoc.first][curLoc.second] != "-") {
                    waiting.push(line[curLoc.first][curLoc.second]);
                    line[curLoc.first][curLoc.second] = "-";
                }
                curLoc = nextLoc(curLoc);
                if (curLoc.first >= nLine) {
                    answer = "BAD";
                    break;
                }
            }
            if (answer == "BAD") break;
            line[curLoc.first][curLoc.second] = "-";
            curLoc = nextLoc(curLoc);
            tickets.erase(target);
        }
    }
    cout << answer;
}
int main() {
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);

    set<string, ticketCompare> tickets;
    vector<vector<string>> line;
    cin >> nLine;
    for (int i = 0; i < nLine; i++) {
        vector<string> sub;
        for (int j = 0; j < COL; j++) {
            string s; cin >> s;
            tickets.insert(s);
            sub.push_back(s);
        }
        line.push_back(sub);
    }
    solution(tickets, line);
}
```
```c++
// 2ì°¨ ì‹œë„
#include <iostream>
#include <vector>
#include <set>
#include <stack>
#include <queue>
#define COL 5

using namespace std;

struct ticketCompare {
    bool operator()(const string& t1, const string& t2) const {
        if (t1[0] == t2[0]) {
            return stoi(t1.substr(2, t1.length())) < stoi(t2.substr(2, t2.length()));
        }
        return t1 < t2;
    }
};

set<string, ticketCompare> tickets;
vector<queue<string>> line;
int nLine; 

void solution() {
    string answer = "GOOD"; // positive thinker
    stack<string> waiting;
    int curLine = 0;
    while (!tickets.empty()) {
        auto target = tickets.begin();

        if (!waiting.empty() && waiting.top() == *target) {
            waiting.pop();
            tickets.erase(target);
        }
        else if (curLine >= nLine) {
            answer = "BAD";
            break;
        }
        else if (line[curLine].front() == *target) {
            line[curLine].pop();
            if (line[curLine].size() == 0) curLine++;
            tickets.erase(target);
        }
        else {
            while (line[curLine].front() != *target) {
                waiting.push(line[curLine].front());
                line[curLine].pop();
                if (line[curLine].size() == 0) curLine++;
                if (curLine >= nLine) {
                    answer = "BAD";
                    break;
                }
            }
            if (answer == "BAD") break;
            line[curLine].pop();
            if (line[curLine].size() == 0) curLine++;
            tickets.erase(target);
        }
    }
    cout << answer;
}
int main() {
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);

    cin >> nLine;
    for (int i = 0; i < nLine; i++) {
        queue<string> sub;
        for (int j = 0; j < COL; j++) {
            string s; cin >> s;
            tickets.insert(s);
            sub.push(s);
        }
        line.push_back(sub);
    }
    solution();
}
```



