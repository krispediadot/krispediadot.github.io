---
layout: post
title: λ°±μ¤€ 14503. λ΅λ΄‡ μ²­μ†κΈ°
date: 2021-03-26 16:20:00 +09:00
modified: 
category: problem solving
tags: [ps, c++, simulation]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

### λ¬Έμ  λ§ν¬
[https://www.acmicpc.net/problem/14503](https://www.acmicpc.net/problem/14503)

### λ‚μ μƒκ°μ νλ¦„
π’΅ [1μ°¨ μ‹λ„ - μ‹¤ν¨] β‡Ά ν‹€λ Έμµλ‹λ‹¤.<br>
    μ„¤λ…μ μ§€μ‹μ— λ”°λΌ μ½”λ“ μ‘μ„±<br>
    μ΄λ™ λ°©ν–¥: 0-λ¶/1-λ™/2-λ‚¨/3-μ„<br>
    μ…λ ¥μΌλ΅ λ“¤μ–΄μ¤λ” λ΅λ΄‡μ λ°©ν–¥: 0-λ¶/1-μ„/2-λ‚¨/3-λ™<br>
π’΅ [2μ°¨ μ‹λ„ - μ„±κ³µ]<br>
    μ΄λ™ λ°©ν–¥κ³Ό λ΅λ΄‡μ λ°©ν–¥ μΈλ±μ¤ μΌμΉν•λ„λ΅ λ³€κ²½<br>

****λ¬Έμ  λ‚΄μ© μμ„Έν μ½κΈ°!!**

### λ¬Έμ μ μ£Όμ” λ‚΄μ© λ° μ²λ¦¬ λ°©μ•
1. λ΅λ΄‡μ μƒνƒ μ •λ³΄ β†’ `using robot = pair<pair<int, int>, int>`λ΅ μ €μ¥
1. μ΄λ™ λ°©ν–¥κ³Ό λ΅λ΄‡μ λ°©ν–¥ μΈλ±μ¤ μΌμΉν•λ„λ΅ λ³€κ²½
1. 4λ°©ν–¥μ— μ²­μ†ν•  κ³³μ΄ μλ” κ³³ ν™•μΈ β†’ movable() ν•¨μ μ„ μ–Έ
1. μ²­μ†ν•  κ³³μ΄ μλ‹¤λ©΄ λ°©ν–¥ μ „ν™ ν›„ μ „μ§„ 
1. μ²­μ†ν•  κ³³μ΄ μ—†λ‹¤λ©΄ ν›„μ§„ λλ” μΆ…λ£


### μ½”λ“ κµ¬ν„ 
1. **`using robot = pair<pair<int, int>, int>`λ΅ μ €μ¥**<br>
    μ…λ ¥μΌλ΅ λ“¤μ–΄μ¤λ” λ΅λ΄‡μ μƒνƒ μ •λ³΄λ¥Ό robotμ΄λΌλ” νƒ€μ…μ„ μ„ μ–Έν•΄μ„ μ €μ¥ν•λ‹¤.<br>
    ```c++
    using robot = pair<pair<int, int>, int>; // μ „μ—­λ³€μ
    robot bot { {0, 0}, 0};
    cin >> bot.first.first >> bot.first.second >> bot.second;
    ``` 
    <br>
1. **μ΄λ™ λ°©ν–¥κ³Ό λ΅λ΄‡μ λ°©ν–¥ μΈλ±μ¤ μΌμΉν•λ„λ΅ λ³€κ²½**<br>
    μ™Όμ½μΌλ΅ νμ „ν•λ©΄μ„ λ΅λ΄‡μ μ£Όλ³€ 4λ°©ν–¥μ„ μ‚΄ν΄λ³Ό κ²ƒμ΄λ―€λ΅ λ¶/μ„/λ‚¨/λ™ μμ„λ΅ λ°©ν–¥μ„ μ„ μ–Έν•λ‹¤.<br>
    ```c++
    const int dirR[] {-1, 0, 1, 0}; // λ¶μ„λ‚¨λ™ , μ „μ—­λ³€μ
    const int dirC[] {0, -1, 0, 1}; // λ¶μ„λ‚¨λ™ , μ „μ—­λ³€μ
    ```
    <mark>λ¬Έμ μ μ…λ ¥ λ¶€λ¶„μ„ μ μ½μ–΄λ³΄λ©΄ "dκ°€ 0μΈ κ²½μ°μ—λ” λ¶μ½μ„, 1μΈ κ²½μ°μ—λ” λ™μ½μ„, 2μΈ κ²½μ°μ—λ” λ‚¨μ½μ„, 3μΈ κ²½μ°μ—λ” μ„μ½μ„ λ°”λΌλ³΄κ³  μλ” κ²ƒμ΄λ‹¤."</mark>λΌκ³  μ„¤λ…λμ–΄ μλ‹¤.<br>
    μ΄ λ¶€λ¶„μ„ μμ„Έν μ½μ§€ μ•μ•„μ„ μ²«λ²μ§Έ ν’€μ΄ κ²°κ³Ό ν‹€λ Έμµλ‹λ‹¤λ¥Ό λ°›μ•λ‹¤.π…<br><br>
    μ„ μ–Έν• μ΄λ™ λ°©ν–¥κ³Ό μ…λ ¥μΌλ΅ λ“¤μ–΄μ¤λ” λ°©ν–¥μ„ μΌμΉμ‹μΌμ¤€λ‹¤.<br>
    λ΅λ΄‡μ μƒνƒλ¥Ό λ°›μ•„μ¤λ” μ½”λ“μ•„λμ— λ³€ν™ μ½”λ“λ¥Ό μ¶”κ°€ν•λ‹¤.<br>
    ```c++
    robot bot { {0, 0}, 0}; 
    cin >> bot.first.first >> bot.first.second >> bot.second;
    bot.second = (bot.second % 2 == 1) ? ((bot.second == 3) ? 1 : 3) : bot.second;
    ```
    <br>
1. **movable() ν•¨μ μ„ μ–Έ**<br>
    ν• μ„μΉμ—μ„ 4λ°©ν–¥ μ¤‘ μ΄λ™ν•  μ μλ” κ³³μ΄ μλ”μ§€λ¥Ό ν™•μΈν•λ” ν•¨μμ΄λ‹¤.<br>
    μ΄λ¥Ό μ„ν•΄ ν•΄λ‹Ή μ„μΉκ°€ μ§€λ„μ— μ΅΄μ¬ν•λ” μ„μΉμΈμ§€ ν™•μΈν•λ” `is_valid()` ν•¨μλ„ ν•¨κ» μ‘μ„±ν•λ‹¤.<br>
    νΈμλ¥Ό μ„ν•΄ λλ‹¤ ν•¨μλ΅ μ‘μ„±ν–λ‹¤.<br>
    ```c++
    auto is_valid = [](pair<int, int> loc) {
        return loc.first > 0 && loc.first < N - 1 && loc.second > 0 && loc.second < M - 1;
    };
    auto movable = [&](pair<int, int>& loc) {
        for (int dir = 0; dir < 4; dir++) {
            int new_r = loc.first + dirR[dir];
            int new_c = loc.second + dirC[dir];

            if (is_valid({new_r, new_c}) && maze[new_r][new_c] == BLANK)
                return true;
        }
        return false;
    };
    ```
    <br>
1. **μ²­μ†ν•  κ³³μ΄ μλ‹¤λ©΄ λ°©ν–¥ μ „ν™ ν›„ μ „μ§„**<br>
    μ„μ—μ„ μ‘μ„±ν• `movable()` ν•¨μμ κ²°κ³Όκ°€ `true` μ΄λ©΄ λ¬Έμ μ—μ„ μ§€μ‹ν• a λλ” b μ§€μ‹μ‚¬ν•­μ„ λ”°λ¥΄λ©΄ λλ‹¤.<br>
    <br>
    a. μ™Όμ½μ΄ μ²­μ† κ°€λ¥, νμ „ ν›„ μ „μ§„<br>
    b. μ™Όμ½μ΄ μ²­μ† λ¶κ°€λ¥μ΄λ©΄, νμ „ ν›„ μ™Όμ½<br>
    <br>
    μ΄ λ‚΄μ©μ„ μ½”λ“λ΅ κ·Έλ€λ΅ μ‘μ„±ν•λ‹¤.<br>
    ```c++
    if (movable(bot_loc)) {
        // ν„μ¬ λ°©ν–¥μ μ™Όμ½
        bot_dir = (bot_dir + 1) % 4;
        int cnt_turn = 0;
        
        while (cnt_turn < 4) {
            int new_r = bot_loc.first + dirR[bot_dir];
            int new_c = bot_loc.second + dirC[bot_dir];

            // a. μ™Όμ½μ΄ μ²­μ† κ°€λ¥, νμ „ ν›„ μ „μ§„
            if (is_valid({new_r, new_c}) && maze[new_r][new_c] == BLANK) {
                maze[new_r][new_c] = CLEAN;
                cnt++;
                bot_loc = {new_r, new_c};
                break;
            }
            // b. μ™Όμ½μ΄ μ²­μ† λ¶κ°€λ¥μ΄λ©΄, νμ „ ν›„ μ™Όμ½
            bot_dir = (bot_dir + 1) % 4;
            cnt_turn++;
        }
    }
    ```
    <br>
1. **μ²­μ†ν•  κ³³μ΄ μ—†λ‹¤λ©΄ ν›„μ§„ λλ” μΆ…λ£**<br>
    μ„μ—μ„ μ‘μ„±ν• `movable()` ν•¨μμ κ²°κ³Όκ°€ `false` μ΄λ©΄ λ¬Έμ μ—μ„ μ§€μ‹ν• c λλ” d μ§€μ‹μ‚¬ν•­μ„ λ”°λ¥΄λ©΄ λλ‹¤.<br>
    <br>
    c. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄λΌλ©΄, λ°©ν–¥ μ μ§€ & ν›„μ§„<br>
    d. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄κ³ , ν›„μ§„λ„ μ•λλ©΄ λ<br>
    <br>
    μ΄ λ‚΄μ©μ„ μ½”λ“λ΅ κ·Έλ€λ΅ μ‘μ„±ν•λ‹¤.<br> 
    ```c++
    else {
        // ν›„μ§„ λ°©ν–¥
        int bot_dir_back = (bot_dir + 2) % 4;
        
        int new_r = bot_loc.first + dirR[bot_dir_back];
        int new_c = bot_loc.second + dirC[bot_dir_back];

        // c. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄λΌλ©΄, λ°©ν–¥ μ μ§€ & ν›„μ§„
        if (is_valid({new_r, new_c}) && maze[new_r][new_c] != WALL) {
            if (maze[new_r][new_c] != CLEAN) cnt++;
            maze[new_r][new_c] = CLEAN;
            bot_loc = {new_r, new_c};
        }
        // d. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄κ³ , ν›„μ§„λ„ μ•λλ©΄ λ
        else {
            break;
        }
    }
    ```
    <br>

### μ „μ²΄ μ½”λ“
```c++
#include <iostream>
#include <vector>

using namespace std;

const int BLANK = 0;
const int WALL = 1;
const int CLEAN = 2;

const int dirR[] {-1, 0, 1, 0}; // λ¶μ„λ‚¨λ™ 
const int dirC[] {0, -1, 0, 1}; // λ¶μ„λ‚¨λ™
int N, M;

using robot = pair<pair<int, int>, int>; // { {μ„μΉr, μ„μΉc}, λ°©ν–¥}

// λ΅λ΄‡ μ²­μ†κΈ°μ μ²­μ† μμ—­ κ°μ 
// μ²­μ†κΈ° λ™μ‘ 
// 1. ν„μ¬ μ„μΉ μ²­μ†
// 2. μ™Όμ½ λ°©ν–¥λ¶€ν„° μ°¨λ΅€λ΅ ν™•μΈ
// a. μ™Όμ½μ΄ μ²­μ† κ°€λ¥, νμ „ ν›„ μ „μ§„
// b. μ™Όμ½μ΄ μ²­μ† λ¶κ°€λ¥μ΄λ©΄, νμ „ ν›„ μ™Όμ½
// c. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄λΌλ©΄, λ°©ν–¥ μ μ§€ & ν›„μ§„
// d. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄κ³ , ν›„μ§„λ„ μ•λλ©΄ λ
int solution(robot& bot, vector<vector<int>>& maze) {
    auto is_valid = [](pair<int, int> loc) {
        return loc.first > 0 && loc.first < N - 1 && loc.second > 0 && loc.second < M - 1;
    };
    auto movable = [&](pair<int, int>& loc) {
        for (int dir = 0; dir < 4; dir++) {
            int new_r = loc.first + dirR[dir];
            int new_c = loc.second + dirC[dir];

            if (is_valid({new_r, new_c}) && maze[new_r][new_c] == BLANK)
                return true;
        }
        return false;
    };

    pair<int, int>& bot_loc = bot.first;
    int& bot_dir = bot.second;

    // 1. ν„μ¬ μ„μΉ μ²­μ†
    maze[bot_loc.first][bot_loc.second] = CLEAN;
    int cnt = 1;

    // 2. μ™Όμ½ λ°©ν–¥λ¶€ν„° μ°¨λ΅€λ΅ ν™•μΈ
    while (1) {

        // a, b
        if (movable(bot_loc)) {
            // ν„μ¬ λ°©ν–¥μ μ™Όμ½
            bot_dir = (bot_dir + 1) % 4;
            int cnt_turn = 0;
            
            while (cnt_turn < 4) {
                int new_r = bot_loc.first + dirR[bot_dir];
                int new_c = bot_loc.second + dirC[bot_dir];

                // a. μ™Όμ½μ΄ μ²­μ† κ°€λ¥, νμ „ ν›„ μ „μ§„
                if (is_valid({new_r, new_c}) && maze[new_r][new_c] == BLANK) {
                    maze[new_r][new_c] = CLEAN;
                    cnt++;
                    bot_loc = {new_r, new_c};
                    break;
                }
                // b. μ™Όμ½μ΄ μ²­μ† λ¶κ°€λ¥μ΄λ©΄, νμ „ ν›„ μ™Όμ½
                bot_dir = (bot_dir + 1) % 4;
                cnt_turn++;
            }
        }
        // c, d
        else {
            // ν›„μ§„ λ°©ν–¥
            int bot_dir_back = (bot_dir + 2) % 4;
            
            int new_r = bot_loc.first + dirR[bot_dir_back];
            int new_c = bot_loc.second + dirC[bot_dir_back];

            // c. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄λΌλ©΄, λ°©ν–¥ μ μ§€ & ν›„μ§„
            if (is_valid({new_r, new_c}) && maze[new_r][new_c] != WALL) {
                if (maze[new_r][new_c] != CLEAN) cnt++;
                maze[new_r][new_c] = CLEAN;
                bot_loc = {new_r, new_c};
            }
            // d. λ„¤ λ°©ν–¥ λ¨λ‘ μ²­μ† λκ±°λ‚ λ²½μ΄κ³ , ν›„μ§„λ„ μ•λλ©΄ λ
            else {
                break;
            }
        }
    }

    return cnt;
}

int main() {
    cin >> N >> M;
    
    robot bot { {0, 0}, 0}; cin >> bot.first.first >> bot.first.second >> bot.second;
    bot.second = (bot.second % 2 == 1) ? ((bot.second == 3) ? 1 : 3) : bot.second;

    vector<vector<int>> maze(N, vector<int> (M, 0));
    for (int r = 0; r < N; r++) {
        for (int c = 0; c < M; c++) {
            cin >> maze[r][c];
        }
    }

    cout << solution(bot, maze) << endl;
}

```
