---
layout: post
title: ë°±ì¤€ 2665. ë¯¸ë¡œë§Œë“¤ê¸°
date: 2021-02-07 21:58:47 +09:00
modified: 
category: problem-solving
tags: [ps, c++, bfs]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/2665](https://www.acmicpc.net/problem/2665)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì‹¤íŒ¨]<br>
    ê° ì •ì  ë³„ ì‹œì‘ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ìƒ‰ê³¼ ë„ì°©ì ì—ì„œ ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê²€ì€ ë°© ìˆ˜ ì„¸ê¸°<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    bfsë¡œ ì‹œì‘ì ì—ì„œ ë„ì°©ì ê¹Œì§€ ìµœì†Œ ê²€ì€ ë°© ìˆ˜ í™•ì¸<br>


### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ë°”ë‘‘íŒ ë‚´ í•˜ë‚˜ì˜ ìœ„ì¹˜ì— ë°©ì˜ ìƒ‰ê³¼ ë„ë‹¬í•  ë•Œ ê¹Œì§€ ìµœì†Œ ê²€ì€ë°© ìˆ˜ ì •ë³´ë¥¼ ì €ì¥í•´ì•¼í•¨ â†’ ë°”ë‘‘íŒì€ pairë¥¼ ì›ì†Œë¥¼ ê°€ì§€ëŠ” 2ì°¨ì› ë°°ì—´ë¡œ í‘œí˜„
1. 4ë°©í–¥ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥ â†’ ë°©í–¥ ì¡°ì ˆ
1. ë°”ë‘‘íŒ ì‚´í´ ë³´ëŠ” ë°©ì‹ â†’ bfs

### ì½”ë“œ êµ¬í˜„ 
1. **ë°”ë‘‘íŒì€ pairë¥¼ ì›ì†Œë¥¼ ê°€ì§€ëŠ” 2ì°¨ì› ë°°ì—´ë¡œ í‘œí˜„**<br>
    ```c++
    #define MAX 51
    pair<int,int> map[MAX][MAX]; // pair<black?white, blocked>
    ```
1. **ë°©í–¥ ì¡°ì ˆ**<br>
    ```c++
    int dirX[] = {0, 1, 0, -1}; // ì „ì—­ ë³€ìˆ˜
    int dirY[] = {1, 0, -1, 0}; // ì „ì—­ ë³€ìˆ˜
    ```
1. **bfs**<br>
    queueë¥¼ ì‚¬ìš©í•´ bfs 
    ```c++
    #include<queue>
    void bfs() {
        queue<pair<int, int>> q;
        map[0][0].second = 0;
        q.push(make_pair(0, 0));

        while (!q.empty()) {
            auto target = q.front();
            q.pop();

            for (int dir = 0; dir < 4; dir++) {
                int nextX = target.first + dirX[dir];
                int nextY = target.second + dirY[dir];

                if (isValid(nextX, nextY) && map[target.first][target.second].second < map[nextX][nextY].second) {
                    map[nextX][nextY].second = map[target.first][target.second].second;
                    if (map[nextX][nextY].first == BLACK)
                        map[nextX][nextY].second++;
                    q.push(make_pair(nextX, nextY));
                }
            }
        }
    }
    ```

### ì „ì²´ ì½”ë“œ
```c++
#include <iostream>
#include <set>
#include <queue>
#define MAX 51
#define BLACK 0
#define WHITE 1

using namespace std;

int dirX[] = {0, 1, 0, -1};
int dirY[] = {1, 0, -1, 0};

pair<int,int> map[MAX][MAX]; // pair<black?white, blocked>
set<int> blocked;
int n;

bool isValid(int i, int j) {
    return i >= 0 && i < n && j >= 0 && j < n;
}
void bfs() {
    queue<pair<int, int>> q;
    map[0][0].second = 0;
    q.push(make_pair(0, 0));

    while (!q.empty()) {
        auto target = q.front();
        q.pop();

        for (int dir = 0; dir < 4; dir++) {
            int nextX = target.first + dirX[dir];
            int nextY = target.second + dirY[dir];

            if (isValid(nextX, nextY) && map[target.first][target.second].second < map[nextX][nextY].second) {
                map[nextX][nextY].second = map[target.first][target.second].second;
                if (map[nextX][nextY].first == BLACK)
                    map[nextX][nextY].second++;
                q.push(make_pair(nextX, nextY));
            }
        }
    }
}
void solution() {
    bfs();
    cout << map[n - 1][n - 1].second;
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        string s; cin >> s;
        int jIdx = 0; 
        for (auto each : s) {
            map[i][jIdx++] = make_pair(each - '0', n * n); //charë¼ ìˆ«ìë¡œ ë³€ê²½
        }
    }
    solution();
}
```




