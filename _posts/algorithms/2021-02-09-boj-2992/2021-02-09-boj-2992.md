---
layout: post
title: ë°±ì¤€ 2992. í¬ë©´ì„œ ì‘ì€ ìˆ˜
date: 2021-02-09 14:48:00 +09:00
modified: 
category: algorithms
tags: [ps, c++, string, recursion]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/2992](https://www.acmicpc.net/problem/2992)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì‹¤íŒ¨] â‡¢ ì‹œê°„ ì´ˆê³¼<br>
    multisetì„ ì‚¬ìš©í•´ ë‘ ìˆ˜ê°€ ê°™ì€ ìˆ«ìë¡œ êµ¬ì„±ë˜ì–´ìˆëŠ”ì§€ í™•ì¸<br>
    ì…ë ¥ ê°’ ë‹¤ìŒë¶€í„° ê°™ì€ ìˆ«ìë¡œ êµ¬ì„±ëœ ìˆ˜ê°€ ë‚˜ì˜¬ ë•Œ ê¹Œì§€ ë¹„êµ<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br>
    stl - algorithm next_permutation ì‚¬ìš©<br>
ğŸ’¡ [3ì°¨ ì‹œë„ - ì„±ê³µ]<br>
    multisetì„ ì‚¬ìš©í•˜ê³  recursionìœ¼ë¡œ ëª¨ë“  ê²½ìš° ì‚´í´ë³´ê¸°<br>

### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ê°™ì€ ìˆ«ìë¡œ êµ¬ì„±ë˜ì–´ìˆëŠ”ì§€ í™•ì¸ â†’ next_permutation(2ì°¨ ì‹œë„)/ recursion(3ì°¨ ì‹œë„)<br>

### ì½”ë“œ êµ¬í˜„ 
1. **next_permutation(2ì°¨ ì‹œë„)**<br>
    c++ STL ì¤‘ algorithmì— next_permutation í•¨ìˆ˜ê°€ ìˆë‹¤.<br>
    next_permutation í•¨ìˆ˜ ìì²´ê°€ í¬ë©´ì„œ ì‘ì€ ìˆ˜ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ìˆë‹¤ë©´ true/ ì—†ë‹¤ë©´ falseë¥¼ ë¦¬í„´í•˜ë¯€ë¡œ ì•„ë˜ì™€ ê°™ì´ ì‚¬ìš©í•˜ë©´ ëœë‹¤.<br>
    ```c++
    string s; cin >> s;
    bool able = next_permutation(s.begin(), s.end());

    if (able) cout << s;
    else cout << 0;
    ```
1. **recursion(3ì°¨ ì‹œë„)**<br>
    ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¨ ìˆ˜ì˜ ê° ìˆ«ìë¥¼ <mark>ì¤‘ë³µ ì›ì†Œ í—ˆìš©ì´ ê°€ëŠ¥í•œ multiset</mark>ì— ì €ì¥<br>
    ì¤‘ë³µ í—ˆìš©ì´ ë¶ˆê°€ëŠ¥í•œ setì— ì €ì¥í•  ê²½ìš° í‹€ë ¸ë‹¤ëŠ” ê²°ê³¼ë¥¼ ë°›ëŠ”ë‹¤.<br>
    ```c++
    #include <set>
    multiset<char> s;
    for (auto each : in) s.insert(each);
    ```

    soluton í•¨ìˆ˜ì—ì„œ ë¶ˆê°€ëŠ¥í•˜ë‹¤ê³  ë‚˜ì˜¤ë©´ 0ì„ ì¶œë ¥
    ```c++
    bool possible = solution(s, "");

    if (!possible) cout << 0; 
    ```

    ì´ì œ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë©´ ëœë‹¤.<br>
    solution í•¨ìˆ˜ëŠ” recursionìœ¼ë¡œ ìƒˆë¡œìš´ ìˆ˜ë¥¼ ë§Œë“¤ê³  ë§Œì•½ í•´ë‹¹ ìˆ˜ê°€ ì…ë ¥ê°’ë³´ë‹¤ í¬ë©´ true/ í°ê°’ì´ ì—†ìœ¼ë©´ falseë¥¼ ë¦¬í„´í•˜ë©´ ëœë‹¤.<br>
    
    <mark>í° ìˆ˜ê°€ ë‚˜ì˜¤ìë§ˆì ì…ë ¥ê°’ ë³´ë‹¤ í¬ë©´ì„œ ì‘ì€ ê°’ì„ì„ í™•ì‹ í•  ìˆ˜ ìˆëŠ” ì´ìœ ëŠ” multisetì´ ì •ë ¬ë˜ì–´ìˆê¸° ë•Œë¬¸ì— recursionì˜ ê²°ê³¼ë¡œ ì‘ì€ ìˆ˜ë¶€í„° ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ìƒì„±í•˜ê¸° ë•Œë¬¸ì´ë‹¤.</mark><br>

    solution í•¨ìˆ˜ì˜ ì „ì²´ ë‚´ìš©ì€ ì•„ë˜ì™€ ê°™ë‹¤.<br>
    ```c++
    bool solution(multiset<char> s, string newS) {
        if (s.empty()) {
            if (stoi(newS) > stoi(in)) {
                cout << newS;
                return true;
            }
        }
        bool possible = false;
        for (auto itr = s.begin(); itr != s.end(); itr++) {
            multiset<char> sub = s;
            char target = *itr;
            sub.erase(sub.find(target));
            possible = solution(sub, newS + target);
            if (possible) break;
        }
        return possible;
    }
    ```

### ì „ì²´ ì½”ë“œ
```c++
// 2ì°¨ ì‹œë„ - next_permutation()
#include <iostream>
#include <algorithm>

using namespace std;

int main(){
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);
    string s; cin >> s;

    bool able = next_permutation(s.begin(), s.end());

    if (able) cout << s;
    else cout << 0;
}
```
```c++
// 3ì°¨ ì‹œë„ - recursion
#include <iostream>
#include <set>

using namespace std;

string in; 

bool solution(multiset<char> s, string newS) {
    if (s.empty()) {
        if (stoi(newS) > stoi(in)) {
            cout << newS;
            return true;
        }
    }
    bool possible = false;
    for (auto itr = s.begin(); itr != s.end(); itr++) {
        multiset<char> sub = s;
        char target = *itr;
        sub.erase(sub.find(target));
        possible = solution(sub, newS + target);
        if (possible) break;
    }
    return possible;
}
int main() {
    ios_base::sync_with_stdio(false);
	cin.tie(NULL);
    cin >> in;
    multiset<char> s;
    for (auto each : in) s.insert(each);

    bool possible = solution(s, "");

    if (!possible) cout << 0; 
}
```
