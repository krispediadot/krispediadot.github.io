---
layout: post
title: ë°±ì¤€ 17135. ìºìŠ¬ë””íœìŠ¤
date: 2021-04-06 12:00:00 +09:00
modified: 
category: algorithms
tags: [ps, c++, simulation]
image: "/assets/img/avatar_code.png"
cover: "../puzzle.jpg"
---

**Index**
1. [ë¬¸ì œ ë§í¬](#ë¬¸ì œ-ë§í¬)
1. [ë‚˜ì˜ ìƒê°ì˜ íë¦„](#ë‚˜ì˜-ìƒê°ì˜-íë¦„)
1. [ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ](#ë¬¸ì œì˜-ì£¼ìš”-ë‚´ìš©-ë°-ì²˜ë¦¬-ë°©ì•ˆ)
1. [ì½”ë“œ êµ¬í˜„](#ì½”ë“œ-êµ¬í˜„)
1. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

### ë¬¸ì œ ë§í¬
[https://www.acmicpc.net/problem/17135](https://www.acmicpc.net/problem/17135)

### ë‚˜ì˜ ìƒê°ì˜ íë¦„
ğŸ’¡ [1ì°¨ ì‹œë„ - ì‹¤íŒ¨] â‡¢ ê°’ì´ ë‹¤ë¦„<br> 
    `<algorithm>` í—¤ë”ì˜ `next_permutation` ì‚¬ìš©<br>
    `get_distance` í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ì„œ ë§¨í•´íƒ„ ê±°ë¦¬ êµ¬í•˜ë„ë¡ ê³„ì‚°<br>
ğŸ’¡ [2ì°¨ ì‹œë„ - ì„±ê³µ]<br> 
    recursionìœ¼ë¡œ ìˆœì—´ êµ¬í˜„<br>
    `bfs` ë°©ì‹ìœ¼ë¡œ ê±°ë¦¬ ê³„ì‚°<br>

****1ì°¨ ì‹œë„ì˜ ì˜ˆì™¸ì‚¬í•­ì„ ì•„ì§ ì°¾ì§€ ëª»í•¨**

### ë¬¸ì œì˜ ì£¼ìš” ë‚´ìš© ë° ì²˜ë¦¬ ë°©ì•ˆ
1. ê¶ìˆ˜ì˜ ìœ„ì¹˜ â†’ recursionìœ¼ë¡œ ëª¨ë“  ê²½ìš° í™•ì¸<br>
1. ì‹œë®¬ë ˆì´ì…˜ â†’ `kill_enemies` í•¨ìˆ˜ êµ¬í˜„<br>
1. ê°€ê¹Œì´ ìˆëŠ” ì  ì°¾ê¸° â†’ `bfs` ì‚¬ìš©<br>


### ì½”ë“œ êµ¬í˜„ 
1. **recursionìœ¼ë¡œ ê¶ìˆ˜ 3ëª…ì˜ ìœ„ì¹˜ ëª¨ë“  ê²½ìš° í™•ì¸**<br>
    ê¶ìˆ˜ì˜ ìœ„ì¹˜ ì¸ë±ìŠ¤ëŠ” ì—´ì˜ ê¸¸ì´ì¸ 0 ~ M-1 ì¤‘ í•˜ë‚˜<br>
    ```cpp
    void solution(vector<pair<int, int>> killers, int& answer) {
        if (killers.size() == KILLERS_TOTAL) {
            answer = max(answer, kill_enemies(killers));
            return;
        }
        for (int idx = 0; idx < M; idx++) {
            killers.push_back({N,idx});

            solution(killers, answer);

            killers.pop_back();
        }
    }
    ```
    <br>
1. **`kill_enemies` í•¨ìˆ˜ êµ¬í˜„**<br>
    ë™ì‘ ë°©ì‹ì„ ì½”ë“œë¡œ ì‘ì„±<br>
    ```c++
    int kill_enemies(vector<pair<int, int>>& killers_copy) {

        vector<pair<int, int>> enemies_copy = enemies;
        int killed_cnt = 0;

        int time_limit = N;
        while (time_limit--) {
            vector<int> target_enemies_idx(KILLERS_TOTAL);

            // 1. ê°€ê¹Œìš´ ì  ì°¾ê¸°
            for (int killer_idx = 0; killer_idx < KILLERS_TOTAL; killer_idx++) {
                pair<int, int>& killer_loc = killers_copy[killer_idx];
                
                int target_enemy_idx = get_near_enemy_idx(killer_loc, enemies_copy);
                target_enemies_idx[killer_idx] = target_enemy_idx;
            }

            // 2. ì  ì œê±°
            for (int killer_idx = 0; killer_idx < KILLERS_TOTAL; killer_idx++) {
                int target_enemy_idx = target_enemies_idx[killer_idx];

                if (target_enemy_idx < enemies_copy.size() && enemies_copy[target_enemy_idx].first != N) {
                    enemies_copy[target_enemy_idx].first = N;
                    killed_cnt++;
                }
            }

            // 3. ë‚¨ì•„ìˆëŠ” ì  ì•„ë˜ë¡œ ì´ë™
            for (int enemy_idx = 0; enemy_idx < enemies_copy.size(); enemy_idx++) {
                if (enemies_copy[enemy_idx].first != N) {
                    enemies_copy[enemy_idx].first++;
                }
            }

            // 4. ì ì´ ëª¨ë‘ ì œê±°ë˜ë©´ ë
            int enemy_left = 0;
            for (auto enemy : enemies_copy) {
                if (enemy.first != N) {
                    enemy_left++;
                }
            }
            if (enemy_left == 0) break;
        }

        return killed_cnt;
    }
    ```
    <br>
1. **`bfs` ì‚¬ìš©í•´ì„œ ê°€ê¹Œì´ ìˆëŠ” ì  ì°¾ê¸°**<br>
    ê¶ìˆ˜ì˜ ìœ„ì¹˜ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ 4ë°©í–¥ ì´ë™í•˜ë©° ì  ì°¾ê¸°<br>
    <makr>ì—¬ê¸°ì„œ ì£¼ì˜í•  ì ì€ ê°€ê¹Œì´ ìˆì–´ë„ ì™¼ìª½ì— ìˆëŠ” ì ì„ ì„ íƒí•´ì•¼ í•˜ë¯€ë¡œ ë°©í–¥ì´ ì„œë¶ë™ë‚¨ ìˆœì„œë¼ëŠ” ì ì´ë‹¤.</mark><br>
    ```c++
    int get_near_enemy_idx(pair<int, int>& killer_loc, vector<pair<int, int>>& enemies_copy) {
    
        const int dirR[] = {0, -1, 0, 1}; // ì„œë¶ë™ë‚¨
        const int dirC[] = {-1, 0, 1, 0};

        queue<pair<pair<int, int>, int>> q;
        q.push({killer_loc, 0});

        while (!q.empty()) {
            auto target = q.front(); q.pop();
            pair<int, int> target_loc = target.first;
            int dist = target.second;

            if (dist > D) break;

            for (int dir = 0; dir < 4; dir++) {
                int next_r = target_loc.first + dirR[dir];
                int next_c = target_loc.second + dirC[dir];

                auto itr = find(enemies_copy.begin(), enemies_copy.end(), make_pair(next_r, next_c));

                if (is_valid(next_r, next_c)) {
                    if (dist + 1 <= D && itr != enemies_copy.end()) {
                        return itr-enemies_copy.begin();
                    }
                    q.push({{next_r, next_c}, dist + 1});
                }
            }
        }
        return -1;
    }
    ```
### ì „ì²´ ì½”ë“œ
```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

const int KILLERS_TOTAL = 3;

int N, M, D;
vector<pair<int, int>> enemies;

bool is_valid(int r, int c) {
    return r >= 0 && r < N && c >= 0 && c < M;
}

int get_near_enemy_idx(pair<int, int>& killer_loc, vector<pair<int, int>>& enemies_copy) {
    
    const int dirR[] = {0, -1, 0, 1}; // ì„œë¶ë™ë‚¨
    const int dirC[] = {-1, 0, 1, 0};

    queue<pair<pair<int, int>, int>> q;
    q.push({killer_loc, 0});

    while (!q.empty()) {
        auto target = q.front(); q.pop();
        pair<int, int> target_loc = target.first;
        int dist = target.second;

        if (dist > D) break;

        for (int dir = 0; dir < 4; dir++) {
            int next_r = target_loc.first + dirR[dir];
            int next_c = target_loc.second + dirC[dir];

            auto itr = find(enemies_copy.begin(), enemies_copy.end(), make_pair(next_r, next_c));

            if (is_valid(next_r, next_c)) {
                if (dist + 1 <= D && itr != enemies_copy.end()) {
                    return itr-enemies_copy.begin();
                }
                q.push({{next_r, next_c}, dist + 1});
            }
        }
    }
    return -1;
}

int kill_enemies(vector<pair<int, int>>& killers_copy) {

    vector<pair<int, int>> enemies_copy = enemies;
    int killed_cnt = 0;

    int time_limit = N;
    while (time_limit--) {
        vector<int> target_enemies_idx(KILLERS_TOTAL);

        // 1. ê°€ê¹Œìš´ ì  ì°¾ê¸°
        for (int killer_idx = 0; killer_idx < KILLERS_TOTAL; killer_idx++) {
            pair<int, int>& killer_loc = killers_copy[killer_idx];
            
            int target_enemy_idx = get_near_enemy_idx(killer_loc, enemies_copy);
            target_enemies_idx[killer_idx] = target_enemy_idx;
        }

        // 2. ì  ì œê±°
        for (int killer_idx = 0; killer_idx < KILLERS_TOTAL; killer_idx++) {
            int target_enemy_idx = target_enemies_idx[killer_idx];

            if (target_enemy_idx < enemies_copy.size() && enemies_copy[target_enemy_idx].first != N) {
                enemies_copy[target_enemy_idx].first = N;
                killed_cnt++;
            }
        }

        // 3. ë‚¨ì•„ìˆëŠ” ì  ì•„ë˜ë¡œ ì´ë™
        for (int enemy_idx = 0; enemy_idx < enemies_copy.size(); enemy_idx++) {
            if (enemies_copy[enemy_idx].first != N) {
                enemies_copy[enemy_idx].first++;
            }
        }

        // 4. ì ì´ ëª¨ë‘ ì œê±°ë˜ë©´ ë
        int enemy_left = 0;
        for (auto enemy : enemies_copy) {
            if (enemy.first != N) {
                enemy_left++;
            }
        }
        if (enemy_left == 0) break;
    }

    return killed_cnt;
}

// ì œê±°í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì ì˜ ìˆ˜
void solution(vector<pair<int, int>> killers, int& answer) {
    if (killers.size() == KILLERS_TOTAL) {
        answer = max(answer, kill_enemies(killers));
        return;
    }
    for (int idx = 0; idx < M; idx++) {
        killers.push_back({N,idx});

        solution(killers, answer);

        killers.pop_back();
    }
}

int main() {
    cin >> N >> M >> D;

    for (int r = 0; r < N; r++) {
        for (int c = 0; c < M; c++) {
            int stat; cin >> stat;

            if (stat == 1) enemies.push_back({r, c});
        }
    }

    int answer = 0;
    vector<pair<int, int>> killers;

    solution(killers, answer);

    cout << answer << endl;
}
```
